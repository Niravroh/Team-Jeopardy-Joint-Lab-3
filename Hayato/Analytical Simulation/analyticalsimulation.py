# -*- coding: utf-8 -*-
"""AnalyticalSimulation.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lGxkBX_1EDA_zSjd5UEmzNm9GMKAVN-E
"""

# ECE183DA Capstone - Joint Lab Analytical Simulation
# Farooq Akhtar
# Hayato Kato
# Matthew Jeong

import math
import numpy as np
import matplotlib.pyplot as plt
from google.colab import files
import pandas as pd

# Global Constants
rw = 90 # Robot width (mm)
rd = 10 # Robot wheel diameter (mm)
rl = 75 # Robot length (mm)
eh = 1000 # Environment height (mm)
ew = 1000 # Environment width (mm)
delta_t = 0.001 # Time elapsed between iterations

#Initializing settings to be determined by switch case
rightTrajectory = []
leftTrajectory = []
initX = 0
initY = 0
initTheta = 0
  
# Linda Segway
def linda_s():
  set_segway()
  global rightTrajectory
  global leftTrajectory
  global initX
  global initY
  global initTheta
  # Trajectory 1
  #leftTrajectory = np.rad2deg([0,1,2,1,0,1,2,1,0])
  #rightTrajectory = np.rad2deg([0,1,2,2,2,2,2,1,0])

  # Paperbot - Trajectory 2
  #left_trajectory_code =  [0,0.25,0.5,0.75,1,1,1,1,1,1.5,2,3,3.5,4,4,4,4,4,3   ,2  ,1   ,0]
  #right_trajectory_code = [0,1   ,2,  3,   4,4,4,4,4,3.5,3,2,1.5,1,1,1,1,1,0.75,0.5,0.25,0]

  # Segway - Trajectory 2
  #left_trajectory_code =  [0,1,2,2,2,1,0,0,1,2,2,2,2,2,2,2,2,2,2,1,0,0,1,2,2,2,2,2,2,2,2,2,2,1,0]
  #right_trajectory_code = [0,1,2,2,2,2,2,2,2,2,2,2,1,0,0,1,2,2,2,2,2,2,2,2,2,2,1,0,0,1,2,2,2,1,0]

  # Segway - Trajectory 3 (pivot turn)
  #left_trajectory_code =  [0, 1, 2, 3, 3, 3, 3, 3, 2, 1, 0,-1,-2,-3,-3,-3,-3,-3,-2,-1,0]
  #right_trajectory_code = [0,-1,-2,-3,-3,-3,-3,-3,-2,-1, 0, 1, 2, 3, 3, 3, 3, 3, 2, 1,0]

  # Segway - Trajectory 4 
  #left_trajectory_code =  [0,1,2,3,2,1,0,0,-1,-3,-5,-3,-1,0,0,1,2,3,2,1,0,0,-1,-3,-5,-3,-1,0,0,1,2,3,2,1,0]
  #right_trajectory_code = [0,1,3,5,3,1,0,0,-1,-2,-3,-2,-1,0,0,1,3,5,3,1,0,0,-1,-2,-3,-2,-1,0,0,1,3,5,3,1,0]
  left_trajectory_code =  [0,1,2,3,2,1,0,-1,-3,-5,-3,-1,0,1,2,3,2,1,0]
  right_trajectory_code = [0,1,3,5,3,1,0,-1,-2,-3,-2,-1,0,1,3,5,3,1,0]


  leftTrajectory =  np.rad2deg(left_trajectory_code)
  rightTrajectory = np.rad2deg(right_trajectory_code)

  # Trajectory 3
  #leftTrajectory = np.rad2deg([0,1  ,2,2  ,2,2,1.5,1,0.5,0])
  #rightTrajectory = np.rad2deg([0,0.5,1,1.5,2,2,2  ,2,1,  0])

  # Trajectory 4
  #leftTrajectory =  np.rad2deg([0,1,2,3,2,1,2,3,2,1,0])
  #rightTrajectory = np.rad2deg([0,0,0,1,2,3,2,1,0,0,0])

  initX = 5000
  initY = 5000
  initTheta = np.pi/2
  
# Linda PaperBot
def linda_p():
  set_paperbot()
  global rightTrajectory
  global leftTrajectory
  global initX
  global initY
  global initTheta
  rightTrajectory = [0, 10, 20, 30, 40, 50, 60, 70, 70]
  leftTrajectory = [0, 10, 20, 10, 0, -10, -20, -30, -20]
  initX = 500
  initY = 500
  initTheta = np.pi/4

# Jaewon Segway
def jaewon_s():
  set_segway()
  global rightTrajectory
  global leftTrajectory
  global initX
  global initY
  global initTheta
  rightTrajectory = [0, 176, 342, 294.49, 294.49, 389.51]
  leftTrajectory = [0, 176, 342, 389.51, 389.51, 294.49]
  initX = 8000
  initY = 1000
  initTheta = np.pi
  
# Jaewon PaperBot
def jaewon_p():
  set_paperbot()
  global rightTrajectory
  global leftTrajectory
  global initX
  global initY
  global initTheta
  rightTrajectory = [0, 177, 344, 263, 263, 344, 425, 344, 117, 0, -258]
  leftTrajectory = [0, 177, 344, 425, 425, 344, 263, 344, 177, 0, -96]
  initX = 800
  initY = 100
  initTheta = np.pi
  
# Niravroh PaperBot
def niravroh_p():
  set_paperbot()
  global rightTrajectory
  global leftTrajectory
  global initX
  global initY
  global initTheta
  rightTrajectory = [100, 75, 50, 25, 0, -25]
  leftTrajectory = [-25, 0, 25, 50, 75, 100]
  initX = 500
  initY = 500
  initTheta = -np.pi/4  

# Niravroh Segway
def niravroh_s():
  set_segway()
  global rightTrajectory
  global leftTrajectory
  global initX
  global initY
  global initTheta
  rightTrajectory = [-25, 0, 25, 50, 75, 100]
  leftTrajectory = [100, 75, 50, 25, 0, -25]
  initX = 5000
  initY = 5000
  initTheta = -np.pi/4

# Morin Paperbot
def morin_p():
  set_paperbot()
  global rightTrajectory
  global leftTrajectory
  global initX
  global initY
  global initTheta
  rightTrajectory = [-180, -200, -220, -239.93, -220, -200]
  leftTrajectory = [-220, -200, -180, -160.07, -180, -200]
  initX = 304.8
  initY = 304.8
  initTheta = -np.pi/2 
  
def set_data(idx):
  data = {0 : linda_s,
          1 : linda_p,
          2 : jaewon_s,
          3 : jaewon_p,
          4 : niravroh_s,
          5 : niravroh_p,
          6 : morin_p
  }
  data[idx]()

def set_segway():
  global rw
  global rd
  global rl
  global eh
  global ew
  rw = 530
  rd = 502
  rl = 682
  eh = 10000
  ew = 10000
  
def set_paperbot():
  global rw
  global rd
  global rl
  global eh
  global ew
  rw = 90
  rd = 50
  rl = 75
  eh = 1000
  ew = 1000
  
def deg_to_rad(trajectory):
  mapping = map(math.radians, trajectory)
  return list(mapping)

def smoothTrajectory(init_traj):
  trajectory = []
  for i in np.arange(len(init_traj)-1):
    linearTrajectory = np.linspace(init_traj[i], init_traj[i+1], int(1/delta_t)+1)
    trajectory.extend(linearTrajectory[:len(linearTrajectory)-1])
  return trajectory
  

class WheelRobot():
  def __init__(self, rw, rd, rl, x, y, theta):
    self.width = rw # Width of the robot's drivetrain
    self.diameter = rd # Diameter of the robot's wheels
    self.theta = theta # Theta of the robot
    self.length = rl # Length of the robot
    self.state = [x, y, theta] # Current state of the robot (x&y=position, theta=orientation)
    
  def move(self, wl, wr, debug=False):
    # System Dynamics
    #temp_theta = self.state[2] + self.diameter/self.width*(wr-wl)*delta_t
    #temp_x = self.state[0] + self.diameter/2*(wr+wl)*math.cos(math.degrees(temp_theta))*delta_t
    #temp_y = self.state[1] + self.diameter/2*(wr+wl)*math.sin(math.degrees(temp_theta))*delta_t
    temp_theta = self.state[2] + self.diameter/(2*self.width)*(wr-wl)*delta_t
    temp_x = self.state[0] + self.diameter/4*(wr+wl)*math.cos(0.5*(self.state[2]+temp_theta))*delta_t
    temp_y = self.state[1] + self.diameter/4*(wr+wl)*math.sin(0.5*(self.state[2]+temp_theta))*delta_t
    

    temp_state = [temp_x, temp_y, temp_theta]
    

    # Output Equation
    wallX = [0,ew,ew,0]
    wallY = [0,0,eh,eh]
    
    maxLength = math.sqrt(eh*eh+ew*ew)

    #print("maxlength:",maxLength)
    
    x1 = temp_state[0]
    y1 = temp_state[1]
    x2_f = x1 + maxLength*math.cos(temp_state[2])
    y2_f = y1 + maxLength*math.sin(temp_state[2])
    x2_r = x1 + maxLength*round(math.cos(temp_state[2]-math.pi/2),4)
    y2_r = y1 + maxLength*round(math.sin(temp_state[2]-math.pi/2),4)
    px_f = -1
    py_f = -1
    px_r = -1
    py_r = -1
    for i in range(4):
      x3 = wallX[i]
      y3 = wallY[i]
      j = i+1
      if j >= 4:
        j=0
      x4 = wallX[j]
      y4 = wallY[j]

      #print("Point2_f:",x2_f,y2_f)
      #print("Point2_r:",x2_r,y2_r)
      
      denominator_f = (x1-x2_f)*(y3-y4)-(y1-y2_f)*(x3-x4)
      if denominator_f == 0:
        continue
      m_f = ((x1-x3)*(y3-y4)-(y1-y3)*(x3-x4))/denominator_f
      n_f = ((x2_f-x1)*(y1-y3)-(y2_f-y1)*(x1-x3))/denominator_f
      
      if m_f >= 0 and m_f <= 1 and n_f >= 0 and n_f <= 1:
        px_f = x1+m_f*(x2_f-x1)
        py_f = y1+m_f*(y2_f-y1)
        
      denominator_r = (x1-x2_r)*(y3-y4)-(y1-y2_r)*(x3-x4)
      if denominator_r == 0:
        continue
      m_r = ((x1-x3)*(y3-y4)-(y1-y3)*(x3-x4))/denominator_r
      n_r = ((x2_r-x1)*(y1-y3)-(y2_r-y1)*(x1-x3))/denominator_r
      
      if m_r >= 0 and m_r <= 1 and n_r >= 0 and n_r <= 1:
        px_r = x1+m_r*(x2_r-x1)
        py_r = y1+m_r*(y2_r-y1)
      #print("--------")
      #print(denominator_r)
      #print(m_r)
      #print(n_r)
      #print("--------")
   
    #print("END OF LOOP")
    #print(px_f,py_f)
    #print(px_r,py_r)
    #print(maxLength)
    #print(x1,y1)
    #print(x2,y2)
    #print(x3,y3)
    #print(x4,y4)

    if px_f == -1 and py_f == -1:
      px_f = temp_state[0]
      py_f = 0
    if px_r == -1 and py_r == -1:
      px_r = temp_state[0]
      py_r = 0

    # Sensor Output
    D_f = math.sqrt((px_f-temp_state[0])*(px_f-temp_state[0])+(py_f-temp_state[1])*(py_f-temp_state[1]))
    D_r = math.sqrt((px_r-temp_state[0])*(px_r-temp_state[0])+(py_r-temp_state[1])*(py_r-temp_state[1]))
    Omega = temp_state[2] - self.state[2]
    B_x = -math.cos(temp_state[2])
    B_y = math.sin(temp_state[2])
    
    output = [D_f, D_r, Omega, B_x, B_y]
    
    #print("Output: ",output)
    
    self.state = temp_state

    #if debug:
      #print("X pos: " + str(round(self.state[0],2)) + "\tY pos: " + str(round(self.state[1],2)) + "\tTheta: " + str(round(math.degrees(self.state[2]),2)))
    
    return (output)
    #return (px_f, py_f, px_r, py_r)
  #def draw(self):

class Enviro():
  def __init__(self, h, w):
    # Initialize class variables
    self.enviroHeight = h
    self.enviroWidth = w
    self.wheelRobot = WheelRobot(rw, rd, rl, initX, initY, initTheta)

  def draw_sightlines(self, x_sightline_f, y_sightline_f, x_sightline_r, y_sightline_r, title=""):
    drawState = self.wheelRobot.state
    x_coord = [drawState[0]]
    y_coord = [drawState[1]]
    x_dir = math.cos(drawState[2])
    y_dir = math.sin(drawState[2])
    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.set_title(title)
    ax.set_xlim([0., ew])
    ax.set_ylim([0., eh])
    ax.grid()
    plt.plot(x_coord[0],y_coord[0], marker = 'o')
    #plt.plot([x_coord[0], x_sightline_f], [y_coord[0], y_sightline_f], color = "red", linestyle = "--", marker = "o")
    #plt.plot([x_coord[0], x_sightline_r], [y_coord[0], y_sightline_r], color = "red", linestyle = "--", marker = "o")
    #q = ax.quiver(x_coord, y_coord, x_sightline_f - float(x_coord[0]), y_sightline_f - float(y_coord[0]), angles = "xy",headwidth=10,headaxislength=5)
    ax.set_aspect('equal', adjustable='box')
    
  def draw_robot(self, ax):
    length = 200
    ax.plot(self.wheelRobot.state[0],self.wheelRobot.state[1],color = "black",marker = 'o')
    ax.plot([self.wheelRobot.state[0],self.wheelRobot.state[0]+length*math.cos(self.wheelRobot.state[2])],[self.wheelRobot.state[1],self.wheelRobot.state[1]+length*math.sin(self.wheelRobot.state[2])],color = "green")


def translate(value, leftMin, leftMax, rightMin, rightMax):
  # Figure out how 'wide' each range is
  leftSpan = leftMax - leftMin
  rightSpan = rightMax - rightMin

  # Convert the left range into a 0-1 range (float)
  valueScaled = float(value - leftMin) / float(leftSpan)

  # Convert the 0-1 range into a value in the right range.
  return rightMin + (valueScaled * rightSpan)

def main():
  set_data(0)

  fig1 = plt.figure(1)
  ax = fig1.add_subplot(111)
  ax.set_title("Field")
  ax.set_xlim([0., ew])
  ax.set_ylim([0., eh])
  ax.grid()
  ax.set_aspect('equal', adjustable='box')

  env = Enviro(eh, ew)

  smoothLeft = smoothTrajectory(leftTrajectory)
  smoothRight = smoothTrajectory(rightTrajectory)

  output = np.empty([len(smoothLeft),10])

  for t in np.arange(0, len(smoothLeft)):
    #print(t)
    speed_modifier = 1

    left_speed = np.deg2rad(speed_modifier*smoothLeft[t])
    right_speed = np.deg2rad(speed_modifier*smoothRight[t])

    result = env.wheelRobot.move(left_speed,right_speed)
    env.draw_robot(ax)

    lidar_F = result[0]
    lidar_R = result[1]

    lidar_F_code = translate(result[0],0,10000,0,4096)
    lidar_R_code = translate(result[1],0,10000,0,4096)

    output[t] = [-left_speed,-right_speed , (env.wheelRobot.state[0]-5000)/1000, (env.wheelRobot.state[1]-5000)/1000, np.rad2deg(env.wheelRobot.state[2]),lidar_F_code,lidar_R_code,result[2],result[3],result[4]]

  
  outputPD = pd.DataFrame(output, columns = ['L Velocity','R Velocity','X Position', 'Y Position', 'Theta','LiDAR F','LiDAR R','Gyro','Compass X','Compass Y'])
  print(outputPD)
  outputPD.to_csv("analyticalSim.csv")

if __name__ == '__main__':
  main()

files.download("analyticalSim.csv")